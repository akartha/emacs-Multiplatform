#+STARTUP: overview
#+TITLE: Emacs Config - Linux
#+CREATOR: Inspired by Dawid 'daedreth' Eckert and other much more talented people
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
* Basic Settings
    These are settings that do not depend on packages and are built-in enhancements to the UI.
** Custom file location
#+begin_src emacs-lisp
(setq custom-file (locate-user-emacs-file "custom-vars.el"))
(load custom-file 'noerror 'nomessage)
#+end_src
** Some standard UI and behavioral settings
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)

(setq inhibit-startup-message t ;Remove the startup screen
      use-dialog-box nil
      ring-bell-function 'ignore
      make-backup-files nil
      auto-save-default t
      global-auto-revert-non-file-buffers t ;; Revert Dired and other buffers
      history-length 25
      ;;Show the current line and column for your cursor.
      line-number-mode t
      column-number-mode t
      display-time-24hr-format t
      display-time-format "%H:%M - %d %B %Y"
      scroll-conservatively 100
      kill-ring-max 100
;;;    Indenting
      indent-line-function 'insert-tab)


(savehist-mode 1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(global-auto-revert-mode 1)
(recentf-mode 1)
(save-place-mode t)     ;; Remember cursor position even after quitting file
(display-time-mode 1)
(global-subword-mode 1) ;;Emacs treats camelCase strings as a single word by default, this changes said behaviour.
(show-paren-mode 1) ;;Highlights matching parens when the cursor is just behind one of them.

;;Set locale to utf-8 in a myriad number of places
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
(defalias 'yes-or-no-p 'y-or-n-p)

#+end_src

* Dired

#+begin_src emacs-lisp
(use-package dired
  :straight nil
  :custom ((dired-listing-switches "-agho --group-directories-first --time-style=long-iso")
;;  :custom ((dired-listing-switches "-agho --group-directories-first --time-style=\'+%Y%m%d %H:%M:%S\'")
           (dired-recursive-copies 'always)
           (dired-recursive-deletes 'always)

    )
  :commands (dired dired-jump)
  :bind (("C-x C-j" . dired-jump)
         ("C-x 4 C-j" . dired-jump-other-window))
)
(use-package dired-single
  :straight t)
(use-package all-the-icons-dired
  :straight t
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package dired-du
  :straight t)
 ;; :hook (dired-mode . dired-du-mode))

(use-package dired-open
  :straight t
  :config
  (setq dired-open-extensions '(("png" . "feh")
                                ("m4a" . "mpv")
                                ("mkv" . "vlc")
                                ("mp4" . "vlc")
                                ("mp3" . "mpv")
                                ("avi" . "vlc")
                                ("opus" . "mpv"))))

(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :straight t
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
            (lambda ()
              (unless (file-remote-p default-directory)
                (auto-revert-mode))))
  :config
  (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
  (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

  (setq dired-sidebar-subtree-line-prefix "__")
  (setq dired-sidebar-theme 'vscode)
  (setq dired-sidebar-use-term-integration t)
  (setq dired-sidebar-use-custom-font t))
#+end_src
* Auto Update packages
#+begin_src emacs-lisp
(use-package auto-package-update
  :straight t
  :config
  (setq auto-package-update-delete-old-versions t
        auto-package-update-interval 5
        auto-package-update-prompt-before-update t
        auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+end_src
* Looks
** A nice theme

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :straight t
  :init
  ;; (setq modus-themes-common-palette-overrides
  ;;       '((fg-prompt fg-main)
  ;;         (bg-prompt bg-yellow-nuanced) ; try to replace "nuanced" or "subtle" with "intense"

  ;;         (comment yellow-faint)
  ;;         (string green-warmer)

  ;;         (fg-heading-1 blue-warmer)
  ;;         (bg-heading-1 bg-blue-nuanced)
  ;;         (overline-heading-1 blue)

  ;;         (fg-heading-2 green-warmer)
  ;;         (bg-heading-2 bg-green-nuanced)
  ;;         (overline-heading-2 border)
  
  ;;         (fg-heading-3 fg-main)
  ;;         (bg-heading-3 bg-dim)
  ;;         (overline-heading-3 border))
  
  ;;       modus-themes-completions
  ;;       '((matches . (extrabold underline))
  ;;         (selection . (extrabold italic underline))))

  ;; (load-theme 'modus-vivendi t))
  (load-theme 'modus-operandi-tinted t)) ;;(load-theme 'modus-operandi-tinted/deuteranopia t))
#+END_SRC
** Fontaine

#+begin_src emacs-lisp
(use-package fontaine
  :straight t)

(setq fontaine-latest-state-file
      (locate-user-emacs-file "fontaine-latest-state.eld"))

;; (setq fontaine-presets
;;       '((regular
;;          :default-family "Hack Nerd Font"
;;          :default-weight normal
;;          :default-height 110
;;          :fixed-pitch-family "Fira Code"
;;          :fixed-pitch-weight nil ; falls back to :default-weight
;;          :fixed-pitch-height 1.0
;;          :variable-pitch-family "Noto Sans"
;;          :variable-pitch-weight normal
;;          :variable-pitch-height 1.0
;;          :bold-family nil ; use whatever the underlying face has
;;          :bold-weight bold
;;          :italic-family "Source Code Pro"
;;          :italic-slant italic
;;          :line-spacing 1)
;;         (medium
;;          :default-family "Iosevka Comfy"
;;          :default-weight semilight
;;          :default-height 140
;;          :fixed-pitch-family nil ; falls back to :default-family
;;          :fixed-pitch-weight nil ; falls back to :default-weight
;;          :fixed-pitch-height 1.0
;;          :variable-pitch-family "FiraGO"
;;          :variable-pitch-weight normal
;;          :variable-pitch-height 1.05
;;          :bold-family nil ; use whatever the underlying face has
;;          :bold-weight bold
;;          :italic-family nil
;;          :italic-slant italic
;;          :line-spacing nil)
;;         (large
;;          :default-family "Hack Nerd Font Mono"
;;          ;;         :default-family "Iosevka"
;;          :default-weight semilight
;;          :default-height 180
;;          :fixed-pitch-family nil ; falls back to :default-family
;;          :fixed-pitch-weight nil ; falls back to :default-weight
;;          :fixed-pitch-height 1.0
;;          :variable-pitch-family "FiraGO"
;;          :variable-pitch-weight normal
;;          :variable-pitch-height 1.05
;;          :bold-family nil ; use whatever the underlying face has
;;          :bold-weight bold
;;          :italic-family nil ; use whatever the underlying face has
;;          :italic-slant italic
;;          :line-spacing 1)))

(setq fontaine-presets
      '((regular
         :default-height 110)
        (medium
         :default-weight semilight
         :default-height 140)
        (large
         :default-weight semilight
         :default-height 180
         :bold-weight extrabold)
        (t ; our shared fallback properties
         :default-family "Iosevka Comfy"
         :default-weight normal
         ;; :default-height 100
         :fixed-pitch-family nil ; falls back to :default-family
         :fixed-pitch-weight nil ; falls back to :default-weight
         :fixed-pitch-height 1.0
         :variable-pitch-family "FiraGO"
         :variable-pitch-weight normal

  :variable-pitch-height 1.05
         :bold-family nil ; use whatever the underlying face has
         :bold-weight bold
         :italic-family nil
         :italic-slant italic
         :line-spacing nil)))
    
(fontaine-restore-latest-preset)

;; Use `fontaine-recovered-preset' if available, else fall back to the
;; desired style from `fontaine-presets'.
;; (if-let ((state fontaine-recovered-preset))
;;     (fontaine-set-preset state)
;;   (fontaine-set-preset 'regular))
(fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))

;; The other side of `fontaine-restore-latest-preset'.
(add-hook 'kill-emacs-hook #'fontaine-store-latest-preset)

(add-hook 'modus-themes-after-load-theme-hook #'fontaine-apply-current-preset)

;; fontaine does not define any key bindings.  This is just a sample that
;; respects the key binding conventions.  Evaluate:
;;
;;     (info "(elisp) Key Binding Conventions")
(define-key global-map (kbd "C-c F") #'fontaine-set-preset)
(define-key global-map (kbd "C-c g") #'fontaine-set-face-font)

#+end_src
** All The Icons
#+begin_src emacs-lisp
(use-package all-the-icons
  :straight t)
#+end_src

** Modeline
Spaceline is the mode line of choice. looks nice and you can set nice separators. Using the =all-the-icons= package gives you more eye-candy.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :straight t
  :config
  (require 'spaceline-config)
  (setq spaceline-buffer-encoding-abbrev-p nil
        ;; spaceline-line-column-p nil
        ;; spaceline-line-p nil
        powerline-default-separator (quote utf-8))
  (spaceline-spacemacs-theme))

(use-package spaceline-all-the-icons
  :straight t
  :after spaceline
  :config
  (setq spaceline-all-the-icons-separator-type 'none)
  (spaceline-all-the-icons-theme))
  ;; (spaceline-all-the-icons--setup-neotree))
#+END_SRC
* Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
(use-package async
  :straight t
  :init (dired-async-mode 1))
#+END_SRC

** Custom keymap

Define a custom keymap for myself

#+begin_src emacs-lisp
(define-prefix-command 'ak-map)
(global-set-key (kbd "`") 'ak-map)
(global-set-key (kbd "` `") 'self-insert-command)
;;(define-key ak-map "`" "`")
#+end_src
** Server mode
#+begin_src emacs-lisp
;;(server-start t)

;;(define-key ak-map "9" 'server-start)
#+end_src
* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :straight t
  :custom (visual-line-mode t)
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-items '((bookmarks  . 10)
                          (recents  . 20)
                          (projects  . 10)))
  ;; (agenda  . 5)))
  (setq dashboard-set-heading-icons t
        dashboard-center-content t
        dashboard-set-file-icons t
        dashboard-set-navigator nil
        dashboard-footer-messages (list (shell-command-to-string "fortune")))
  (add-hook 'dashboard-mode-hook (lambda ()
                                   (visual-line-mode 1)))
  :bind (:map ak-map
              ("1" . (lambda ()
                       (interactive)
                       (switch-to-buffer "*dashboard*")))))

#+END_SRC

* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :straight t
  :init
  (projectile-mode +1)
  :bind (:map projectile-mode-map
              ("C-c p" . projectile-command-map)))

#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

** Go projectile tools
#+begin_src emacs-lisp
;; (use-package go-projectile
;;   :straight t)

#+end_src

* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

** a prerequisite for other packages
#+BEGIN_SRC emacs-lisp
                                        ;  (use-package ivy
                                        ;   :ensure t)
#+END_SRC

** which-key
#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :straight t
  :config
  (which-key-setup-side-window-right-bottom)
  (which-key-mode))

#+end_src
** Windows, panes
*** Switch-window
With 3 or more, upon pressing =C-x o= , the buffers turn a solid color and each buffer is asigned a letter. Pressing a letter asigned to a window will take you to the window.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :straight t
  :config
  (setq switch-window-input-style 'minibuffer
        switch-window-increase 4
        switch-window-threshold 2
        switch-window-shortcut-style 'qwerty
        switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
  ([remap other-window] . switch-window))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.

Modified to also open the previous buffer in the newly opened window
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1 nil)
  (if (= prefix 1)
      (switch-to-next-buffer)))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1)
  (if (= prefix 1)
      (switch-to-next-buffer)))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Swiper
In emacs, you mostly use search to get around your buffers; swiper makes sure this is more efficient.
#+BEGIN_SRC emacs-lisp
;; (use-package swiper
;;   :ensure t
;;   :bind ("C-s" . 'swiper))
#+END_SRC

#+RESULTS:

** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.

*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
#+BEGIN_SRC emacs-lisp
;;(global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
;;;;;; (setq ibuffer-expert t)
#+END_SRC
*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

** Line numbers and programming
I highly recommend not enabling =linum-relative-mode= globally, as it messed up something like =ansi-term= for instance.
#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :diminish
  :straight t
  :config
  (setq linum-relative-current-symbol "")
  (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

** Helm

[[https://github.com/emacs-helm/helm][Helm github]]

*** helm
#+BEGIN_SRC emacs-lisp
;; (use-package helm
;;   :diminish
;;   :ensure t
;;   :preface (require 'helm-config)
;;   :bind
;;   ("C-x C-f" . 'helm-find-files)
;;   ("C-x C-b" . 'helm-buffers-list)
;;   ("M-x" . 'helm-M-x)
;;   :config
;;   (defun daedreth/helm-hide-minibuffer ()
;;     (when (with-helm-buffer helm-echo-input-in-header-line)
;; (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
;;   (overlay-put ov 'window (selected-window))
;;   (overlay-put ov 'face
;;         (let ((bg-color (face-background 'default nil)))
;;       `(:background ,bg-color :foreground ,bg-color)))
;;   (setq-local cursor-type nil))))
;;   (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
;;   (setq helm-autoresize-max-height 0
;;   helm-autoresize-min-height 40
;;   helm-M-x-fuzzy-match t
;;   helm-buffers-fuzzy-matching t
;;   helm-recentf-fuzzy-match t
;;   helm-semantic-fuzzy-match t
;;   helm-imenu-fuzzy-match t
;;   helm-split-window-in-side-p nil
;;   helm-move-to-line-cycle-in-source nil
;;   helm-ff-search-library-in-sexp t
;;   helm-scroll-amount 8
;;   helm-echo-input-in-header-line t)
;;   :init
;;   (helm-mode 1))

;; ;;  (require 'helm-config)
;;   (helm-autoresize-mode 1)
;;   (define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
;;   (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
#+END_SRC

** Vertico
#+begin_src emacs-lisp
;; Enable vertico
(use-package vertico
  :straight (:files (:defaults "extensions/*"))
  :init
  (vertico-mode)

  ;; Different scroll margin
  ;; (setq vertico-scroll-margin 0)

  ;; Show more candidates
  (setq vertico-count 15)

  ;; Grow and shrink the Vertico minibuffer
  ;; (setq vertico-resize t)

  ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
  :custom
  (setq vertico-cycle t))

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :init
  (savehist-mode))

;; A few more useful configurations...
(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))

;; Configure directory extension.
(use-package vertico-directory
  :after vertico
  :ensure nil
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

#+end_src

** Consult
#+begin_src emacs-lisp
;; Example configuration for Consult
(use-package consult
  :straight t
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ;;         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key (kbd "M-.")
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  )
#+end_src

** Embark
#+begin_src emacs-lisp
(use-package embark
  :straight t
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :straight t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Orderless

#+begin_src emacs-lisp

(use-package orderless
  :straight t
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(basic orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles basic orderless)))))

 
#+end_src


** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :after vertico
  :straight t
  :custom (marginalia-annotators '(marginalia-annottators-heavy marginalia-annottators-light nil))
  :init (marginalia-mode))

#+end_src

** All the icons in completion
#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :straight t 
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init (all-the-icons-completion-mode))
#+end_src
** avy
As you invoke one of avy's functions, you will be prompted for a character that you'd like to jump to in the /visible portion of the current buffer/.
Afterwards you will notice how all instances of said character have additional letter on top of them. Pressing those letters, that are next to your desired character will move your cursor over there.

[[https://github.com/abo-abo/avy][Avy github]]

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'avy-custom-keymap)
(global-set-key (kbd "` y") 'avy-custom-keymap)
;; (define-key avy-custom-keymap "z" '(lambda () (interactive) (message "testing")))

(use-package avy
  :straight t
  :bind
  (:map avy-custom-keymap
        ("l" . avy-goto-line)
        ;;    ("L" . avy-move-line)
        ("m" . avy-move-region)
        ;;        ("p" . avy-goto-line-above)
        ;;      ("n" . avy-goto-line-below)
        ("c" . avy-goto-char-timer)
        ("w" . avy-goto-word-0)
        ("t" . avy-transpose-lines-in-region)
        ;;  ("k" . avy-kill-ring-save-whole-line)
        ;;  ("K" . avy-kill-whole-line)
        ("r" . avy-kill-ring-save-region)
        ("R" . avy-kill-region)
        ("s" . avy-goto-symbol-1)
        ("h" . avy-org-goto-heading-timer)))

(defun ak/avy-org-table-1-char ()
  "Avy navigation of cells in org-mode tables based on any char in the cell.
    'SPC' can be used to jump to any cell. "
  (interactive)
  ;; set some variables to limit candidates to the current table
  (let ((table-begin (save-excursion (goto-char (org-table-begin)) (previous-line) (point)))
        (table-end (save-excursion (goto-char (org-table-end)) (next-line) (point))))
    ;; jump to the desired cell and re-align
    ;; (goto-char
    (avy-with avy-goto-word-0
      (avy-jump (concat "|\\{1\\}[^-\n|]+" (char-to-string (read-char "char: " t)))
                :window-flip nil
                :beg table-begin
                :end table-end )))
(org-table-end-of-field 1 ))
    
(define-key ak-map "%" 'ak/avy-org-table-1-char)
#+END_SRC

** Scroll with cursor stationary
#+BEGIN_SRC emacs-lisp
(global-set-key [C-down] (kbd "C-u 1 C-v"))
(global-set-key [C-up] (kbd "C-u 1 M-v"))
#+END_SRC
* Text Manipulation
Here I shall collect custom functions that make editing text easier.

** Mark-Multiple
This extension allows you to quickly mark the next occurence of a region and edit them all at once.
#+BEGIN_SRC emacs-lisp
(use-package mark-multiple
  :straight t
  :bind (:map ak-map
              ((">" . mark-next-like-this)
               ("<" . mark-previous-like-this)
               ("+" . mark-more-like-this-extended)
               ("=" . mark-all-like-this))))
;; ("C-c m" . mark-more-like-this-extended)
;; ("C-c a" . mark-all-like-this))
#+END_SRC

** Semantically cycle through selections
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :straight t
  :bind
  ("C-=" . 'er/expand-region)
  ("C-+" . 'er/contract-region)
  ("C-c q" . 'er/mark-inside-quotes)
  ("C-c Q" . 'er/mark-outside-quotes)
  )
#+END_SRC

** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
(defun ak/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1)
  (message "Killed current word"))
(define-key ak-map "W" 'ak/kill-inner-word)
#+END_SRC

** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
(defun ak/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank))
  (message "Copied current word"))
(define-key ak-map "w" 'ak/copy-whole-word)

#+END_SRC

** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
(defun ak/copy-whole-line ()
  "Copies a line without regard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol))))
  (message "Copied current line"))

    (define-key ak-map "l" 'ak/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
;;  (global-set-key (kbd "C-c l k") 'kill-whole-line)
;; (define-key ak-map "L" (lambda ()
;;                           (interactive)
;;                           (kill-whole-line)
;;                           (message "Killed whole line")))
(define-key ak-map "L" 'kill-whole-line)
#+END_SRC

** Move lines up/down
Copied from this [[https://stackoverflow.com/questions/2423834/move-line-region-up-and-down-in-emacs][stackoverflow post]]

#+begin_src emacs-lisp
;; move the line(s) spanned by the active region up/down (line transposing)
(defun move-lines (n)
  (let ((beg) (end) (keep))
    (if mark-active
        (save-excursion
          (setq keep t)
          (setq beg (region-beginning)
                end (region-end))
          (goto-char beg)
          (setq beg (line-beginning-position))
          (goto-char end)
          (setq end (line-beginning-position 2)))
      (setq beg (line-beginning-position)
            end (line-beginning-position 2)))
    (let ((offset (if (and (mark t)
                           (and (>= (mark t) beg)
                                (< (mark t) end)))
                      (- (point) (mark t))))
          (rewind (- end (point))))
      (goto-char (if (< n 0) beg end))
      (forward-line n)
      (insert (delete-and-extract-region beg end))
      (backward-char rewind)
      (if offset (set-mark (- (point) offset))))
    (if keep
        (setq mark-active t
              deactivate-mark nil))))

(defun ak/move-lines-up (n)
  "move the line(s) spanned by the active region up by N lines."
  (interactive "*p")
  (move-lines (- (or n 1))))

(defun ak/move-lines-down (n)
  "move the line(s) spanned by the active region down by N lines."
  (interactive "*p")
  (move-lines (or n 1)))

(define-key ak-map "[" 'ak/move-lines-up)
(define-key ak-map "]" 'ak/move-lines-down)
#+end_src

* Major conveniences
These utilities create a nice environment that fits like a glove

** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
(defun ak/config-visit ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))
;;(global-set-key (kbd "C-c e") 'config-visit)
(define-key ak-map "0" 'ak/config-visit)
#+END_SRC

** Reloading the configuration
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
(defun ak/config-reload ()
  "Reloads ~/.emacs.d/config.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
;;(global-set-key (kbd "C-c r") 'config-reload)
(define-key ak-map "r" 'ak/config-reload)
#+END_SRC

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself
#+BEGIN_SRC emacs-lisp
                                        ;(setq electric-pair-pairs '(
                                        ;                           (?\{ . ?\})
                                        ;                           (?\( . ?\))
                                        ;                           (?\[ . ?\])
                                        ;                           (?\" . ?\")
                                        ;                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
                                        ;(electric-pair-mode t)
#+END_SRC
** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :diminish
  :straight t
  :config
  (beacon-mode 1))
#+END_SRC

** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :diminish
  :straight t
  :init
  (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :diminish
  :straight t
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
** Hungry deletion
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :diminish
  :straight t
  :config
  (global-hungry-delete-mode))
#+END_SRC

** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
If you wish to include the selected character in the killed region, change =zzz-up-to-char= to =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :straight t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC

** Switch to scratch buffer
#+BEGIN_SRC emacs-lisp
(define-key ak-map "z" (lambda ()
                         "Switch to scratch"
                         (interactive)
                         (switch-to-buffer "*scratch*")))
#+END_SRC
** CRUX
#+BEGIN_SRC emacs-lisp
(define-prefix-command 'ak-crux-map)
(global-set-key (kbd "` x") 'ak-crux-map)

(use-package crux
  :straight t
  :bind
  ("C-k" . crux-smart-kill-line)
  (:map ak-crux-map
        ;;     ("U" . crux-view-url)
        ;;("a" . crux-ispell-word-then-abbrev)
        ("." . crux-find-shell-init-file)
        ("1" . crux-find-user-init-file)
        ("a" . crux-move-beginning-of-line)
        ("o" . crux-smart-open-line)
        ("O" . crux-smart-open-line-above)
        ("d" . crux-duplicate-current-line-or-region)
        ("j" . crux-top-join-line)
        ("k" . crux-kill-line-backwards)
        ("C" . crux-cleanup-buffer-or-region)
        ("r" . crux-recentf-find-file)
        ("D" . crux-recentf-find-directory)
        ("U" . crux-upcase-region)
        ("L" . crux-downcase-region)
        ("i" . crux-insert-date)
        ("c" . crux-capitalize-region)
        ("w" . crux-other-window-or-switch-buffer)
        ("s" . crux-sudo-edit)
        ("<f2>" . crux-rename-buffer-and-file)
        ("<tab>" . crux-indent-defun)))
#+END_SRC

crux ships with some handy advises that can enhance the operation of existing commands.
*** (crux-with-region-or-buffer)

You can use crux-with-region-or-buffer to make a command acting normally on a region to operate on the entire buffer in the absence of a region. Here are a few examples you can stuff in your config:
#+begin_example
(crux-with-region-or-buffer indent-region)
(crux-with-region-or-buffer untabify)
#+end_example
*** (crux-with-region-or-line)
Likewise, you can use crux-with-region-or-line to make a command alternately act on the current line if the mark is not active:
#+begin_example
(crux-with-region-or-line comment-or-uncomment-region)
#+end_example
*** (crux-with-region-or-point-to-eol)
Sometimes you might want to act on the point until the end of the current line, rather than the whole line, in the absence of a region:
#+begin_example
(crux-with-region-or-point-to-eol kill-ring-save)
#+end_example
** Popup Kill Ring
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :straight t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Programming
Minor, non-completion related settings and plugins for writing code.
** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :straight t
      :commands yas-minor-mode
      :hook (go-mode . yas-minor-mode)
      :config
        (use-package yasnippet-snippets
          :straight t)
        (yas-reload-all))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish
    :straight t)
#+END_SRC

** company mode
    #+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :config
  (setq company-idle-delay 0
        company-minimum-prefix-length 1))

#+END_SRC

** specific languages
Each category also has additional settings.

*** lspmode settings
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :straight t
  :init
  ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  (setq lsp-keymap-prefix "C-c l")
  :commands lsp lsp-deferred
  :hook (
         (go-mode . lsp-deferred)
         (python-mode . lsp-deferred)
         (rustic-mode . lsp-deferred)
         (lsp-mode . lsp-enable-which-key-integration))
  )

;; Optional - provides fancier overlays

(use-package lsp-ui
  :straight t
  :hook (lsp-mode . lsp-ui-mode)
;;  :config (setq lsp-ui-doc-enable t)
  :commands lsp-ui-mode
  )

;; optionally if you want to use debugger
;; (use-package dap-mode)
;; (use-package dap-LANGUAGE) to load the dap adapter for your language

(setq lsp-ui-doc-enable t
      lsp-ui-peek-enable t
      lsp-ui-sideline-enable t
      lsp-ui-imenu-enable t
      lsp-ui-flycheck-enable t)


#+END_SRC
*** Golang
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :straight t
  :config
  (with-eval-after-load "lsp-mode"
    (add-to-list 'lsp-enabled-clients 'gopls)))

(setq lsp-gopls-staticcheck t
      lsp-eldoc-render-all t
      lsp-gopls-complete-unimported t)

;; set up before-save hooks to ensure buffer formatting and aa/delete imports
;; Make sure there are no other gofmt/goimports hooks enabled

(defun lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))

(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

(with-eval-after-load 'company
  (add-hook 'go-mode-hook 'company-mode))

(use-package ob-go
  :straight t)
#+END_SRC

*** c/c++
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :straight t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :straight t)

  (use-package company-irony
    :straight t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :diminish
    :straight t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** python
#+BEGIN_SRC emacs-lisp
(use-package lsp-jedi
  :straight t
  :config
  (with-eval-after-load "lsp-mode"
    (add-to-list 'lsp-disabled-clients 'pyls)
    (add-to-list 'lsp-enabled-clients 'jedi)))

  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)

  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))


  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :straight t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

*** emacs-lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :straight t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :straight t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC

*** bash
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :straight t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC

*** json


#+BEGIN_SRC emacs-lisp

(use-package json-mode
  :straight t
  :mode (("\\.json\\'" . json-mode)
         ("\\.tmpl\\'" . json-mode)
         ("\\.eslintrc\\'" . json-mode))
  :config (setq-default js-indent-level 2))

(use-package jq-mode
  :straight t
  :mode (("\\.jq$" . jq-mode)))

(with-eval-after-load "json-mode"
  (define-key json-mode-map (kbd "C-c C-j") #'jq-interactively))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package json-reformat
  :straight t
  :after json-mode
  :bind (("C-c f" . json-reformat-region)))

(use-package jq-format
  :straight t
  :demand t
  :after json-mode)    
#+END_SRC

*** Restclient
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :straight t)
(use-package company-restclient
  :straight t)

(use-package ob-restclient
  :straight t)

(with-eval-after-load 'company
  (add-hook 'restclient-mode-hook 'company-mode))

(add-to-list 'company-backends 'company-restclient)

#+END_SRC

*** Rust

#+begin_src emacs-lisp
(use-package rustic
  :straight t
  :bind (:map rustic-mode-map
              ("M-j" . lsp-ui-imenu)
              ("M-?" . lsp-find-references)
              ("C-c C-c l" . flycheck-list-errors)
              ("C-c C-c a" . lsp-execute-code-action)
              ("C-c C-c r" . lsp-rename)
              ("C-c C-c q" . lsp-workspace-restart)
              ("C-c C-c Q" . lsp-workspace-shutdown)
              ("C-c C-c s" . lsp-rust-analyzer-status))
  :config
  ;; uncomment for less flashiness
  ;; (setq lsp-eldoc-hook nil)
  ;; (setq lsp-enable-symbol-highlighting nil)
  ;; (setq lsp-signature-auto-activate nil)
  (with-eval-after-load "lsp-mode"
    (add-to-list 'lsp-enabled-clients 'rust-analyzer))
  ;; comment to disable rustfmt on save
  (setq rustic-format-on-save t)
  (add-hook 'rustic-mode-hook 'rk/rustic-mode-hook))

(defun rk/rustic-mode-hook ()
  ;; so that run C-c C-c C-r works without having to confirm, but don't try to
  ;; save rust buffers that are not file visiting. Once
  ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
  ;; no longer be necessary.
  (when buffer-file-name
    (setq-local buffer-save-without-query t)))
#+end_src

*** SQL
    Requires the installation of pip package =sqlparse= using =pip3 install sqlparse=
#+begin_src emacs-lisp
(defun sqlparse-region (beg end)
  (interactive "r")
  (shell-command-on-region
   beg end
;;   "python3 -c 'import sys, sqlparse; print(sqlparse.format(sys.stdin.read(), identifiers = \"upper\", reindent = True, comma_first = True, indent_columns = True))'"
    "sqlformat --keywords \"upper\" --reindent --indent_columns - "
   t t))


#+end_src

    #+begin_src emacs-lisp
(use-package sqlformat
  :straight t)

    #+end_src

*** awk
    #+begin_src emacs-lisp
      ;; (add-hook 'awk-mode-hook (lambda()
      ;;                            (require 'live-awk)
      ;;                            (live-awk-mode 1)))
      ;; (require 'awk-it)
    #+end_src

*** Mermaid
#+begin_src emacs-lisp
(use-package mermaid-mode
  :straight t)

(use-package ob-mermaid
  :straight t
  :init (setq ob-mermaid-cli-path "~/.nvm/versions/node/v19.5.0/bin/mmdc"))
    
#+end_src
* Magit integration
magit is great. It's easy and intuitive to use, shows its options at a keypress and much more.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :straight t
  :config
  (setq magit-push-always-verify nil
        git-commit-summary-max-length 50)
  :bind (:map ak-map
              ("g" . magit-status)))

#+END_SRC

* Remote editing

** Editing with sudo
Pretty self-explanatory.
#+BEGIN_SRC emacs-lisp
 (use-package sudo-edit
   :straight t
   :bind
     ("s-e" . sudo-edit))
#+END_SRC

* Org
** Common settings

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵"
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t
      org-src-strip-leading-and-trailing-blank-lines t
      org-confirm-babel-evaluate nil
      org-image-actual-width nil
      org-agenda-start-with-log-mode t
      org-log-done 'time
      org-log-into-drawer t

      org-agenda-files '("~/Dropbox/org-files/")

      org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)"  "|" "COMPLETED(c)" "CANC(k@)"))

      org-src-window-setup 'current-window)

(defun ak/org-table-mark-field ()
  "Mark the current table field."
  (interactive)
  ;; Do not try to jump to the beginning of field if the point is already there
  (when (not (looking-back "|\\s-?"))
    (org-table-beginning-of-field 1))
  (set-mark-command nil)
  (org-table-end-of-field 1))

(define-key ak-map "-" 'ak/org-table-mark-field)

(add-hook 'org-mode-hook 'org-indent-mode)
(add-hook 'org-mode-hook 'yas-minor-mode)
(add-hook 'org-mode-hook 'abbrev-mode)
;;(add-hook 'org-mode-hook #'org-modern-mode)

(add-hook 'org-mode-hook
          (lambda ()
            (visual-line-mode 1)))
#+END_SRC

** PDF tool
#+BEGIN_SRC emacs-lisp
(when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
  (require 'xdvi-search))
#+END_SRC
** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :straight t)
#+END_SRC
** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
  ;; (use-package org-bullets
  ;;   :ensure t
  ;;   :config
  ;;     (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!
*** latex
#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat (getenv "PATH") ":/usr/bin"))
;;  (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
;;    (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
;;    (require 'xdvi-search))
#+END_SRC

*** ODT export option
#+BEGIN_SRC emacs-lisp
(require 'ox-odt)
#+END_SRC
*** Twitter Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :straight t)
#+END_SRC

*** Reveal.js export
#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  ;; https://github.com/yjwen/org-reveal
  :straight t
  :config
  (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
  ;;(setq org-reveal-hlevel 2)
  ;;    Change variable org-reveal-hlevel’s value to set HLevel globally.
  ;; Setting Org files local HLevel to option REVEAL_HLEVEL. #+REVEAL_HLEVEL: 2
  ;; org-reveal-title-slide nil)
  ;;   To avoid a title slide, please set variable org-reveal-title-slide to nil, or add reveal_title_slide:nil to #+OPTIONS: line.
  ;; To restore the default title slide, please set variable org-reveal-title-slide to ~’auto~
  ;;   Customize the Title Slide

  ;; There are 3 ways to customize the title slide.

  ;;     Set variable org-reveal-title-slide to a string of HTML markups.
  ;;     Set reveal_title_slide in the #+OPTIONS: line to a string of HTML markups.
  ;;     Use one or more option lines #+REVEAL_TITLE_SLIDE: to specify the HTML of the title slide.

  ;; The following escaping characters can be used to retrieve document information:
  ;; %t	Title
  ;; %s	Subtitle
  ;; %a	Author
  ;; %e	Email
  ;; %d	Date
  ;; %%	Literal %
  )
#+END_SRC


*** Freemind
#+begin_src emacs-lisp
;; (use-package ox-freemind
;;   :ensure t)
#+end_src
** Org Babel languages
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (restclient . t)
   (sql . t)
   ;;    https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-sql.html

   ;; Header Arguments
   ;; The :colnames header argument defaults to "yes".
   ;; There are several SQL-specific header arguments:
   ;; :engine
   ;;     one of "dbi", "monetdb", "msosql", "mysql", "postgresql";
   ;; :cmdline
   ;;     extra command line arguments for the RDBMS executable;
   ;; :dbhost
   ;;     the host name;
   ;; :dbuser
   ;;     the user name;
   ;; :dbpassword
   ;;     the user's password;
   ;; :database
   ;;     the database name;
   ;; #+name: my-query
   ;; #+header: :engine mysql
   ;; #+header: :dbhost host
   ;; #+header: :dbuser user
   ;; #+header: :dbpassword pwd
   ;; #+header: :database dbname
   ;; #+begin_src sql
   ;;   SELECT * FROM mytable
   ;;   WHERE id > 500
   ;; #+end_src
   (sqlite . t)
   (C . t)
   ;;   Example code
   ;;   #+begin_src C++ :includes <stdio.h>
   ;;    int a=1;
   ;;    int b=1;
   ;;    printf("%d\n", a+b);
   ;;   #+end_src

   (awk . t)
   ;; There are three AWK-specific header arguments.
   ;; :cmd-line
   ;;     takes command line arguments to pass to the AWK executable
   ;; :in-file
   ;;     takes a path to a file of data to be processed by AWK
   ;; :stdin
   ;;     takes an Org-mode data or code block reference, the value of which will be passed to the AWK process through STDIN


   ;;    example code
   ;;    #+begin_src awk :stdin inventory-shipped :exports results
   ;;     $1 ~ /J/
   ;;    #+end_src
   (go . t)

   ;;https://github.com/ljos/jq-mode
   (jq . t)
    ;;https://github.com/arnm/ob-mermaid
    (mermaid . t)
   ))
#+END_SRC

# #+begin_src go :imports '("fmt" "time")
#   fmt.Println("Current Time:", time.Now())
# #+end_src

# #+RESULTS:
# : Current Time: 2022-04-06 23:42:34.362804765 -0400 EDT m=+0.000053449

** Org capture stuff
This stuff is kind of moot now that I have org-roam

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)

  (setq org-capture-templates
        '(("j" "Journal" entry (file+datetree "~/Dropbox/org-files/journal.org")
           "* %?\nEntered on %U\n  %i\n  %a")
          ("t" "Todo" entry (file+headline "~/Dropbox/org-files/todo.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("n" "Note" entry (file+headline "~/Dropbox/org-files/notes.org" "Notes")
           "* Note %?\n%T")
          ("l" "Links" entry (file+headline "~/Dropbox/org-files/Links.org" "Links")
           "* %? %^L %^g \n%T" :prepend t)
          ))
;;        org-roam-node-display-template "${title:55} ${tags:*}")

#+END_SRC
** Org Roam
#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :straight t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Dropbox/org-files"))
  (org-roam-completion-everywhere t)
  (org-roam-node-display-template "${title:55} ${tags:*}")
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags:")
      :unnarrowed t)

     ("b" "book notes" plain (file "~/Dropbox/org-files/templates/booknotes.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Book")
      :unnarrowed t)

     ("p" "project" plain (file "~/Dropbox/org-files/templates/projectcap.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
      :unnarrowed t)

     ("r" "random thoughts" plain (file "~/Dropbox/org-files/templates/random.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Musings")
      :unnarrowed t)

     ("m" "movie notes" plain (file "~/Dropbox/org-files/templates/movienotes.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Movies")
      :unnarrowed t)

     ("s" "series notes" plain (file "~/Dropbox/org-files/templates/movienotes.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Series")
      :unnarrowed t)

     ))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         :map org-mode-map
         ("C-M-i" . completion-at-point)
         :map org-roam-dailies-map
         ("Y" . org-roam-dailies-capture-yesterday)
         ("T" . org-roam-dailies-capture-tomorrow))
  :bind-keymap
  ("C-c n d" . org-roam-dailies-map)
  :config
  (require 'org-roam-dailies)
  (org-roam-db-autosync-mode))

#+END_SRC
** Org present
#+begin_src emacs-lisp
(use-package org-present
  :straight t)
#+end_src
** Org modern
#+begin_src emacs-lisp
;; (use-package org-modern
;;   :straight t)
#+end_src

* Diminishing modes
The package =diminish= disables modes on the mode line but keeps them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :straight t
    :init
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'yas-minor-mode)
    (diminish 'org-indent-mode))

#+END_SRC

* Instant messaging
I like IRC, I also like other protocols but I enjoy IRC most, it's obvious that I long
for a way to do my messaging from within emacs.
There is plenty of IRC clients in the repositories, and some more in the emacs repositories
but I find that the default =erc= does the job best, it's easy to use and offers some conveniences
that more sophisticated ones don't, so I use it.

** erc, also known as "a way to ask for help on #emacs"
You might want to edit the default nick, it's password protected anyway so don't bother.

*** Some common settings
This also hides some of the channel messages to avoid cluttering the buffer.
The other line changes the prompt for each channel buffer to match the channel name,
this way you always know who you are typing to.
#+BEGIN_SRC emacs-lisp
 (setq erc-nick "fatman03"
       erc-prompt (lambda () (concat "[" (buffer-name) "]"))
       erc-hide-list '("JOIN" "PART" "QUIT"))
#+END_SRC

*** Poor mans selectable server list
What it says on the tin, this changes the =erc= history to include the server I connect to often.
#+BEGIN_SRC emacs-lisp
(setq erc-server-history-list '("irc.libera.chat"
                                "localhost"))
#+END_SRC

*** Nick highlighting
You can even highlight nicks to make the buffers a bit more visually pleasing and easier to look at.
#+BEGIN_SRC emacs-lisp
(use-package erc-hl-nicks
 :straight t
 :config
   (erc-update-modules))
#+END_SRC

** rich presence for discord
Memes, but it's fun and tiny.
#+BEGIN_SRC emacs-lisp
 ;; (use-package elcord
 ;;   :ensure t)
#+END_SRC

* Mail
** mu14e
#+begin_src emacs-lisp
(use-package mu4e
  :straight nil
  :defer 20
  :config

  (setq user-mail-address "akkartha@gmail.com"
        user-full-name  "Arun Kartha"
        mu4e-compose-signature (concat "Arun Kartha\n"
                                       "mailto:akkartha@gmail.com")
        mu4e-compose-format-flowed t)

  (setq mu4e-change-filenames-when-moving t)

  (setq mu4e-update-interval (* 10 60))
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-maildir "~/Mail")

  (setq mu4e-drafts-folder "/Gmail/[Gmail]/Drafts")
  (setq mu4e-sent-folder "/Gmail/[Gmail]/Sent Mail")
  (setq mu4e-refile-folder "/Gmail/[Gmail]/All Mail")
  (setq mu4e-trash-folder "/Gmail/[Gmail]/Trash")

  (setq mu4e-maildir-shortcuts
        '(("/Inbox"                . ?i)
          ("/Gmail/[Gmail]/Sent Mail"    . ?s)
          ("/Gmail/[Gmail]/Trash"        . ?t)
          ("/Gmail/[Gmail]/Drafts"       . ?d)
          ("/Gmail/[Gmail]/All Mail"     . ?a))))
#+end_src
** SMTP
#+begin_src emacs-lisp
(setq smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 465
      smtpmail-stream-type 'ssl)
#+end_src
* XKCD
For a bit of fun, add xkcd cartoons to your dashboard
#+BEGIN_SRC emacs-lisp
(use-package xkcd
  :straight t)

;; Function to check for internet being up
;; (defun internet-up-p (&optional host)
;;   (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1"
;;                      (if host host "www.google.com"))))

;; (message (if (internet-up-p) "Up" "Down"))
(defun ak/reload-xkcd ()
  "Load a random xkcd cartoon on the dashboard"
  (interactive)
  (let ((rand-id-xkcd nil)
        (rand-id-xkcd-url nil))

    (with-temp-buffer
      (setq rand-id-xkcd (string-to-number(xkcd-rand))
          rand-id-xkcd-url (concat "http://xkcd.com/" (number-to-string rand-id-xkcd)))
    (xkcd-kill-buffer))
  (let ((last-xkcd-png (concat xkcd-cache-dir (number-to-string rand-id-xkcd) ".png")))
    (if (file-exists-p last-xkcd-png)
        (setq dashboard-startup-banner last-xkcd-png
              dashboard-banner-logo-title rand-id-xkcd-url
              dashboard-init-info xkcd-alt))))
  (revert-buffer))

(define-key ak-map "X" 'ak/reload-xkcd)
#+END_SRC
* Experimental features
** Hyperbole
#+begin_src emacs-lisp
;; (use-package hyperbole
;;   :straight t)
#+end_src
** Start page
    #+begin_src emacs-lisp
    ;; (setq initial-buffer-choice "~/start-emacs.org")
    #+end_src
** Modus Theme customizations

#+begin_src emacs-lisp
;; (setq modus-themes-completions
;;       '((matches . (extrabold underline))
;;         (selection . (extrabold italic underline))))
;; (setq modus-themes-org-blocks 'tinted-background)
;; (setq modus-themes-prompts '(extrabold italic))

;; These overrides are common to all Modus themes.  We also provide
;; theme-specific options, such as `modus-operandi-palette-overrides'.
;;
;; In general, the theme-specific overrides are better for overriding
;; color values, such as redefining what `blue-faint' looks like.  The
;; common overrides are best used for changes to semantic color
;; mappings, as we show below.

;; Keep the background unspecified (like the default), but use a faint
;; foreground color.
;; (setq modus-themes-common-palette-overrides
;;       '((fg-prompt cyan-faint)
;;         (bg-prompt unspecified)))

;; ;; Add a nuanced background to prompts that complements their foreground.
;; (setq modus-themes-common-palette-overrides
;;       '((fg-prompt cyan)
;;         (bg-prompt bg-blue-nuanced)))

;; ;; Add a yellow background and adjust the foreground accordingly.
;; (setq modus-themes-common-palette-overrides
;;       '((fg-prompt fg-main)
;;         (bg-prompt bg-yellow-nuanced) ; try to replace "nuanced" or "subtle" with "intense"

;;         (comment yellow-faint)
;;         (string green-warmer)

;;         (fg-heading-1 blue-warmer)
;;         (bg-heading-1 bg-blue-nuanced)
;;         (overline-heading-1 blue)

;;         (fg-heading-2 fg-main)
;;         (bg-heading-2 bg-dim)
;;         (overline-heading-2 border)))

#+end_src
** Avy customs
#+begin_src emacs-lisp
;; (defun avy-goto-parens ()
;;   (interactive)
;;   (let ((avy-command this-command))   ; for look up in avy-orders-alist
;;     (avy-jump "(+")))
;; (add-to-list 'avy-orders-alist '(avy-goto-parens . avy-order-closest))
;; ;;(global-define-key (kbd "s-p") 'avy-goto-parens)
;; (define-key ak-map "(" 'avy-goto-parens)
;; (defun avy-org-same-level (&optional all)
;;   "Go to any org heading of the same level as the current one.

;; By default, choices are limited to headings under common
;; subheading, but if called with a prefix argument, will be
;; buffer-global."
;;   (interactive "P")
;;   (let ((org-level (org-current-level)))
;;     (avy--generic-jump
;;      (format "^%s "
;;              (regexp-quote
;;               (make-string org-level ?*)))
;;      nil
;;      'pre
;;      (unless (or all (= org-level 1))
;;        (save-excursion
;;          (outline-up-heading 1)
;;          (point)))
;;      (unless (or all (= org-level 1))
;;        (save-excursion
;;          (outline-up-heading 1)
;;          (org-end-of-subtree))))))

;; (defun avy-org-parent-level (&optional all)
;;   "Go to any org heading one level above the current one.

;; By default, choices are limited to headings under common
;; subheading, but if called with a prefix argument, will be
;; buffer-global."
;;   (interactive "P")
;;   (let ((org-level (org-current-level)))
;;     (if (= org-level 1)
;;         (message "Already at top level.")
;;       (avy--generic-jump
;;        (format "^%s "
;;                (regexp-quote
;;                 (make-string (- org-level 1) ?*)))
;;        nil
;;        'pre
;;        (unless (or all (= org-level 2))
;;          (save-excursion
;;            (outline-up-heading 2)
;;            (point)))
;;        (unless (or all (= org-level 2))
;;          (save-excursion
;;            (outline-up-heading 2)
;;            (org-end-of-subtree)))))))

;; (defun avy-org-child-level (&optional all)
;;   "Go to any org heading one level below the current one.

;; By default, choices are limited to headings under common
;; subheading, but if called with a prefix argument, will be
;; buffer-global."
;;   (interactive "P")
;;   (if (save-excursion (org-goto-first-child))
;;       (let ((org-level (org-current-level)))
;;         (avy--generic-jump
;;          (format "^%s "
;;                  (regexp-quote
;;                   (make-string (+ org-level 1) ?*)))
;;          nil
;;          'pre
;;          (unless all
;;            (save-excursion
;;              (ignore-errors
;;                (outline-up-heading 0))
;;              (point)))
;;          (unless all
;;            (save-excursion
;;              (ignore-errors
;;                (outline-up-heading 0))
;;              (org-end-of-subtree)))))
;;     (message "Heading has no children.")))

;; (defun avy-org-goto-level (&optional num)
;;   "Prompt for an org level to go to, defaulting to the current one."
;;   (interactive (list
;;                 (read-number "Select heading level: " (org-current-level))))
;;   (avy--generic-jump
;;    (format "^%s " (regexp-quote (make-string num ?*)))
;;    nil
;;    'pre))
#+end_src
